\chapter{Implementazione} \label{chap:implementation}

In questo capitolo verrà descritta l'implementazione del software sviluppato per l'elaborazione di immagini lunari. In particolare, verranno presentate le scelte progettuali e le soluzioni adottate per la realizzazione delle funzionalità di calibrazione, allineamento, pre-processing, stacking e post-processing affrontate nel \cref{chap:techniques}. I codici riportati in questo capitolo sono solo delle parti significative del software, alle quali sono spesso state rimosse diverse linee dove venivano effettuati controlli aggiuntivi o operazioni di supporto. Per una visione completa si rimanda al repository \href{https://github.com/Spina02/Moon-Stacker.git}{GitHub} del progetto.

\section{Architettura del software} \label{sec:architecture}

Il software è stato sviluppato in linguaggio Python, utilizzando principalmente le librerie OpenCV e NumPy per la manipolazione delle immagini. La struttura del software è stata organizzata in moduli, ognuno dei quali si occupa di una specifica funzionalità.

Il file config.py contiene la definizione di alcuni flags (come DEBUG), variabili che contengono path alle cartelle utilizzate (input, output, bias, dark, flat, ...), e alcune funzioni per iniziare tali variabili e le metriche.

All'interno di \texttt{image.py} sono presenti 

\subsection{Calibrazione} \label{subsec:calibration_impl}

La fase di calibrazione è stata implementata nel file \texttt{calibration.py}. Qui sono definiti i metodi pef calcolare i master bias, dark e flat, e quello per applicare la calibrazione alle immagini.

I metodi per calcolare i masters sono ripostati qui sotto seguono la procedura descritta negli algoritmi \ref{alg:bias}, \ref{alg:dark} e \ref{alg:flat}.

\begin{lstlisting}
    # Function to calculate the master bias
    def calculate_master_bias(bias):
        # Calculate the mean
        return np.mean(bias, axis=0)

    # Function to calculate the master dark
    def calculate_master_dark(dark, master_bias=None):
        if master_bias is None: master_bias = np.zeros_like(flat[0])
        # Subtract the master bias, then calculate the mean
        return np.mean(dark - master_bias, axis=0)

    # Function to calculate the master flat
    def calculate_master_flat(flat, master_bias=None, master_dark=None):
        if master_bias is None: master_bias = np.zeros_like(flat[0])
        if master_dark is None: master_dark = np.zeros_like(flat[0])
        # Subtract master bias and dark, then calculate the mean
        master_flat = np.mean(flat-master_bias-master_dark, axis=0)   
        # Normalize the master flat
        if np.mean(master_flat) != 0: master_flat /= np.mean(master_flat)
        
        return master_flat
\end{lstlisting}

Queste funzioni vengono chiamate da una funzione ausiliaria (\texttt{calculate\_masters}) che, prima di calcolare i masters, controlla se i frame di calibrazione sono stati caricati correttamente e se hanno le stesse dimensioni delle immagini da calibrare. In caso contrario, viene sollevata un'eccezione. Inoltre, se per un tipo di frames di calibrazione il numero di frames tipo è inferiore ad una certa soglia \texttt{MIN\_CALIBRATION} specificata nel file di configurazione, il master corrispondente non viene calcolato e viene stampato un messaggio di warning, in quanto con troppi pochi frames il calcolo potrebbe non essere affidabile e introdurre nuovi artefatti.

Questa fase risulta compiutazionalmente molto onerosa, in quanto richiede il caricamento di tutti i frame di calibrazione in memoria, e il calcolo dei master richiede l'elaborazione di ogni singolo pixel di ogni frame. Per questo motivo, è stata implementata la possibilità di salvare i master calcolati su file, in modo da poterli riutilizzare senza doverli ricalcolare ogni volta.

Il metodo per calibrare una singola immagine fa riferimentop all'\cref{alg:calibration}. L'implementazione è la seguente:

\begin{lstlisting}
    # Function to calibrate a single image
    def calibrate_single_image(image, master_bias = None, master_dark = None, master_flat = None):
        if master_bias is None and master_dark is None and master_flat is None:
            print("No calibration masters available: skipping")
            return image
        if master_bias is None: master_bias = np.zeros_like(flat[0])
        if master_dark is None: master_dark = np.zeros_like(flat[0])
        if master_flat is None: master_flat = np.ones_like(flat[0])
        # Calibrate the image
        calibrated = (image - master_bias - master_dark)/master_flat
        calibrated = np.clip(calibrated, 0, 1)  # Clip to valid range
        return calibrated
\end{lstlisting}
    
Dove, sia nel calcolo dei masters, che nella calibrazione di una singola immagine, vi è la possibilità di non utilizzare uno o più set di frame di calibrazione, nel caso in cui non siano disponibili.
Inoltre è stata utilizzata la funzione \texttt{clip} di \texttt{numpy} per assicurarsi che i valori dell'immagine risultante siano compresi tra 0 e 1.

\subsection{Allineamento} \label{subsec:alignment_impl}

\subsection{Pre-processing} \label{subsec:preprocessing_impl}

\subsection{Stacking} \label{subsec:stacking_impl}

\subsection{Post-processing} \label{subsec:postprocessing_impl}

\section{Sfide affrontate e soluzioni adottate} \label{sec:challenges}

- Alto utilizzo di RAM 

- No reference image

- Sfondo non completamente nero 



\cleardoublepage